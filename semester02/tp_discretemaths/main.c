#include <stdio.h>
#include <string.h>
#include <stdlib.h>


// base structure of a rule. fractals are generated by any list of rules
typedef struct{
    // substituition_symbol -> substituition_text 
    // each substituition_symbol is changed to substituition_text every recursion level
    char substituition_symbol;
    char* substituition_text;
    int substituition_text_lenght;
    // if remove_symbol = 1, after string generation ends, every instance of substituition_symbol will be removed
    int remove_symbol;
} rule;

// returns a new and correctly filled rule
rule set_up_rule(char substituition_symbol, char* substituition_text, int remove_symbol){
    rule new_rule;
    new_rule.substituition_symbol = substituition_symbol;
    new_rule.substituition_text = substituition_text;
    new_rule.substituition_text_lenght = strlen(substituition_text)
    new_rule.remove_symbol = remove_symbol;
    return new_rule;
}


// inserts "target" string into "origin" at the specified position
void insert(char* target, char* origin, int position) {
    int base_lenght = strlen(origin);
    int target_lenght = strlen(target);
    memmove(origin + position + target_lenght, origin + position, base_lenght - position + 1);
    memcpy(origin + position, target, target_lenght);
}
// removes a characther at a specified position in a "target" string
void pop(char* target, int position){
    int target_lenght = strlen(target);
    for(int i=position; i<target_lenght; i++){
        target[i] = target[i+1];
    }
}
// replaces a characther in "position" at "origin" string with a "target" string
void replace(char* origin, char* target, int position){
    pop(origin, position);
    insert(target, origin, position);
}


// generates a fractal string and saves it to a file
void generate_fractal_string(char* axioma, rule* rules, int number_of_rules, int max_recusion_level, char* target_filename){
    int fractal_string_lenght = strlen(axioma);
    // recursion level loop
    for(int recursion_level=0; recursion_level<max_recusion_level; recursion_level++){
        // reading each recusion level fractal string
        for(int characther=0; characther<fractal_string_lenght; characther++){
            // applying rules if needed
            for(int rule_number=0; rule_number<number_of_rules; rule_number++){
                if(axioma[characther]==rules[rule_number].substituition_symbol){
                    replace(axioma, rules[rule_number].substituition_text, characther);
                    characther += rules[rule_number].substituition_text_lenght - 1;
                    fractal_string_lenght += rules[rule_number].substituition_text_lenght - 1;
                }
            }
        }
    }
    // removing symbols if needed
    fractal_string_lenght = strlen(axioma);
    for(int characther=0; characther<fractal_string_lenght; characther++){
        for(int rule_number=0; rule_number<number_of_rules; rule_number++){
            if(axioma[characther]==rules[rule_number].substituition_symbol && rules[rule_number].remove_symbol==1){
                pop(axioma, characther);
                fractal_string_lenght--;
                characther--;
            }
        }
    }
    // writing results in a txt file
    FILE* file;
    file = fopen(target_filename, "w");
    fprintf(file, "%s", axioma);
    fclose(file);  
}


int main(){
    int max_recursion_level;
    scanf("%d", &max_recursion_level);

    // setting up koch island (Ilha de Koch)
    char* koch_island_axioma = malloc(sizeof(char)*10000);
    strcpy(koch_island_axioma, "F+F+F+F");
    // setting up rules
    rule koch_island_rules[1];
    koch_island_rules[0] = set_up_rule('F', "F+F-F-FFF+F+F-F", 0);
    // generating fractal string
    generate_fractal_string(koch_island_axioma, koch_island_rules, 1, max_recursion_level, "i.txt");
    free(koch_island_axioma);

    // setting up hilberts space-filling curve (Preenchimento de EspaÃ§o de Hilbert)
    char* hilbert_space_axioma = malloc(sizeof(char)*10000);
    strcpy(hilbert_space_axioma, "X");
    // setting up rules
    rule hilbert_space_rules[2];
    hilbert_space_rules[0] = set_up_rule('X', "-YF+XFX+FY-", 1);
    hilbert_space_rules[1] = set_up_rule('Y', "+XF-YFY-FX+", 1);
    // generating fractal string
    generate_fractal_string(hilbert_space_axioma, hilbert_space_rules, 2, max_recursion_level, "ii.txt");
    free(hilbert_space_axioma);

    // setting up third fractal (not shure wich one yet)
    return 0;
}