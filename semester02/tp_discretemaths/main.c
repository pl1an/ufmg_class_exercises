#include <stdio.h>
#include <string.h>
#include <stdlib.h>


// base structure of a rule. fractals are generated by any list of rules
typedef struct{
    // substituition_symbol -> substituition_text 
    // each substituition_symbol is changed to substituition_text every recursion level
    char substituition_symbol;
    char* substituition_text;
    int substituition_text_lenght;
    // if remove_symbol = 1, after string generation ends, every instance of substituition_symbol will be removed
    int remove_symbol;
} rule;


// inserts "target" string into "origin" at the specified position
void insert(char* target, char* origin, int position) {
    int base_lenght = strlen(origin);
    int target_lenght = strlen(target);
    memmove(origin + position + target_lenght, origin + position, base_lenght - position + 1);
    memcpy(origin + position, target, target_lenght);
}
// removes a characther at a specified position in a "target" string
void pop(char* target, int position){
    int target_lenght = strlen(target);
    for(int i=position; i<target_lenght; i++){
        target[i] = target[i+1];
    }
}
// replaces a characther in "position" at "origin" string with a "target" string
void replace(char* origin, char* target, int position){
    pop(origin, position);
    insert(target, origin, position);
}


// generates a fractal string and saves it to a file
void generate_fractal_string(char* axioma, rule* rules, int number_of_rules, int max_recusion_level, char* target_filename){
    int fractal_string_lenght = strlen(axioma);
    // recursion level loop
    for(int recursion_level=0; recursion_level<max_recusion_level; recursion_level++){
        // reading each recusion level fractal string
        for(int characther=0; characther<fractal_string_lenght; characther++){
            // applying rules if needed
            for(int rule_number=0; rule_number<number_of_rules; rule_number++){
                if(axioma[characther]==rules[rule_number].substituition_symbol){
                    replace(axioma, rules[rule_number].substituition_text, characther);
                    characther += rules[rule_number].substituition_text_lenght - 1;
                    fractal_string_lenght += rules[rule_number].substituition_text_lenght - 1;
                }
            }
        }
    }
    // removing symbols if needed
    fractal_string_lenght = strlen(axioma);
    for(int characther=0; characther<fractal_string_lenght; characther++){
        for(int rule_number=0; rule_number<number_of_rules; rule_number++){
            if(axioma[characther]==rules[rule_number].substituition_symbol && rules[rule_number].remove_symbol==1){
                pop(axioma, characther);
                fractal_string_lenght--;
                characther--;
            }
        }
    }
    // writing results in a txt file
    FILE* file;
    file = fopen(target_filename, "w");
    fprintf(file, "%s", axioma);
    fclose(file);  
}


int main(){
    // creating axioma
    char* axioma = malloc(sizeof(char)*10000);
    strcpy(axioma, "F+F+F+F");
    // setting up rules
    rule rules[1];
    rules[0].remove_symbol = 0;
    rules[0].substituition_symbol = 'F';
    rules[0].substituition_text = "F+F-F-FFF+F+F-F";
    rules[0].substituition_text_lenght = strlen(rules[0].substituition_text);
    // generating fractal string
    generate_fractal_string(axioma, rules, 1, 2, "i.txt");
    printf("%s", axioma);
    free(axioma);
    return 0;
}